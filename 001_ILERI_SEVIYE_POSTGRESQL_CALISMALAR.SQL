SELECT * FROM CUSTOMER; --<< MUSTERILER TABLOSUNU OKUR SELECT ILE KOLONLARI SECER.
SELECT * FROM CUSTOMER_ORDER; --<< MUSTERI VE SIPARISLERI ILISKISEL OLARAK TUTAN TABLOYU OKUR.

--IKI TABLO JOIN
-- CUSTOMER VE CUSTOMER_ORDER TABLOLARINDAKI ESLESEN KAYITLARI GETIRIR.
--ILGILI MUSTERIYE AIT SIPARISLERI GETIRIR.
SELECT *, CUSTOMER.FIRST_NAME, CUSTOMER_ORDER.TOTAL_AMOUNT
FROM CUSTOMER
JOIN CUSTOMER_ORDER
ON CUSTOMER.ID = CUSTOMER_ORDER.CUSTOMER_ID;

--COKLU TABLO JOIN
--MUSTERI, MUSTERIYE AIT SIPARIS, SIPARIS BILGILERI, URUN BILGILERI GELIYOR JOIN'LENMIS TABLOLARDAN.
SELECT *
FROM CUSTOMER
JOIN CUSTOMER_ORDER
ON CUSTOMER.ID = CUSTOMER_ORDER.CUSTOMER_ID
JOIN ORDER_ITEM
ON CUSTOMER_ORDER.ID = ORDER_ITEM.ORDER_ID
JOIN PRODUCT
ON ORDER_ITEM.PRODUCT_ID = PRODUCT.ID;

--ALIAS TAKMA AD KULLANILARAK COKLU JOIN
--MUSTERI, MUSTERIYE AIT SIPARIS, SIPARIS BILGILERI, URUN BILGILERI GELIYOR JOIN'LENMIS TABLOLARDAN.
SELECT *
FROM CUSTOMER AS C
JOIN CUSTOMER_ORDER AS CO
ON C.ID = CO.CUSTOMER_ID
JOIN ORDER_ITEM AS OI
ON CO.ID = OI.ORDER_ID
JOIN PRODUCT AS P
ON OI.PRODUCT_ID = P.ID;

--LEFT JOIN / LEFT ONLY JOIN
--WHERE SARTINDA NULL OLANLARI GETIR DIYOR.
--IKI TABLODA KESISEN KISIM DEGIL SADECE SOL TABLO GELIR.
SELECT *
FROM CUSTOMER
LEFT JOIN CUSTOMER_ORDER ON CUSTOMER.ID = CUSTOMER_ORDER.CUSTOMER_ID
WHERE CUSTOMER_ORDER.ID IS NULL;

--RIGHT JOIN / RIGHT ONLY JOIN
--WHERE SARTINDA NULL OLANLARI GETIR DIYOR.
--IKI TABLODA KESISEN KISIM DEGIL SADECE SAG TABLO GELIR.
SELECT *
FROM CUSTOMER
RIGHT JOIN CUSTOMER_ORDER ON CUSTOMER.ID = CUSTOMER_ORDER.CUSTOMER_ID
WHERE CUSTOMER.ID IS NULL;

--FULL JOIN
--KAC TABLO JOIN OLURSA OLSUN HEM KESISENLER HEMDE KESIYMEYENLER FULL OKUNUR.
SELECT *
FROM CUSTOMER
FULL JOIN CUSTOMER_ORDER ON CUSTOMER.ID = CUSTOMER_ORDER.CUSTOMER_ID;

--INNER JOIN
--KAC TABLO OLURSA OLSUN TABLOLAR ARASI SADECE KESISENLER OKUNUR.
--INNSER JOIN VE JOIN AYNI SEYDIR FARKI YOKTUR.
SELECT *
FROM CUSTOMER
INNER JOIN CUSTOMER_ORDER ON CUSTOMER.ID = CUSTOMER_ORDER.CUSTOMER_ID;

--TABLO OLUSTURMA
--HESAPLAR ADLI TABLO OLUSTURULDU
CREATE TABLE IF NOT EXISTS ACCOUNTS(
    ID BIGSERIAL PRIMARY KEY,
    NAME TEXT NOT NULL,
    BALANCE NUMERIC(19, 2) NOT NULL
);

--HESAPLAR ADLI TABLOYA 2 TANE KAYIT GIRILDI
INSERT
INTO ACCOUNTS(
    NAME, BALANCE
)
VALUES(
    'HUSEYIN', 9999
)
VALUES(
    'ZIYA', 1111
);

--HESAPLAR TABLOSU OKUNDU
SELECT *
FROM ACCOUNTS;

--HESAPLAR TABLOSU UZERINDE GUNCELLEME
--ID'SI 1 OLAMN KULLANICININ BAKIYESINDEN 200 PARA DUSULDU.
UPDATE ACCOUNTS
SET BALANCE = BALANCE - 200
WHERE ID = 1;

BEGIN; --TRANSACTION BASLATIR.
UPDATE ACCOUNTS
SET BALANCE = BALANCE - 200
WHERE ID = 1;
ROLLBACK; --ACILAN TRANSACTION'U VERIYI KALICI HALE GETIRMEDEN GERI ALIR.
COMMIT; --ACILAN TRANSACTION'U YAPILAN DML ISLEMLERINI KALICI HALE GETIRIR.
--TCL DATA INTEGRITY YANI VERI BUTUNLUGU ICINDIR.-
--YA HEP YA HIC MANTIGIYLA CALISIR.
--DML ISLEMLERINDE BIR HATA OLURSA ROLLBACK YAPILARAK ISLEMLER GERI ALINIR.
--VERI TUTARSIZLIGINI ONLER.


SELECT *
FROM ACCOUNTS;

BEGIN; --TRANSACTION BASLATIR.
UPDATE ACCOUNTS
SET BALANCE = BALANCE - 200
WHERE ID = 1;
COMMIT; --VERI KALICI HALE GELIR.

BEGIN; --TRANSACTION BASLATIR.
UPDATE ACCOUNTS
SET BALANCE = BALANCE - 200
WHERE ID = 2;
ROLLBACK; --UPDATE GERI ALINIR. KALICI HALE GELMEZ.

SELECT *
FROM ACCOUNTS
WHERE ID = 1;

SELECT *
FROM CUSTOMER
WHERE EMAIL = '';

CREATE
INDEX ACCOUNTS_BALANCE_IDX --<< INDEX ISMI 
ON ACCOUNTS(BALANCE); --ACCOUNTS TABLOSU UZERUNDE BALANCE ISIMLI KOLON ICIN INDEX OLSUTURUR.

CREATE
INDEX ACCOUNTS_NAME_IDX --<< INDEX ISMI 
ON ACCOUNTS(NAME); --ACCOUNTS TABLOSU UZERUNDE NAME ISIMLI KOLON ICIN INDEX OLSUTURUR.

DROP
INDEX ACCOUNTS_BALANCE_IDX; --INDEX'I DROP EDER SILER.

DROP
INDEX ACCOUNTS_NAME_IDX; --INDEX'I DROP EDER SILER.

SELECT *
FROM ACCOUNTS
WHERE BALANCE = 22;

CREATE TABLE IF NOT EXISTS PEOPLES( --INSANLAR TABLOSU CREATE EDER.
    FIRST_NAME TEXT NOT NULL,
    LAST_NAME TEXT NOT NULL
);

SELECT *
FROM PEOPLES
WHERE FIRST_NAME = 'Jesus';

CREATE --FIRST_NAME KOLONUNA INDEX TANIMLAR.
INDEX PEOPLES_FIRST_NAME_IDX
ON PEOPLES(FIRST_NAME); --AD'A GORE ARAMA YAPILIRKEN OKUMA HIZINI ARTIRMAK ICIN INDEX'LER OLUSTURULUR VE BINARY TREE ALGORITMASINA GORE ARAMA YAPAR.

$> \timing --zamanlamayı acar/kapar. Sorgu sürelerini gösterir.

DROP
INDEX PEOPLES_FIRST_NAME_IDX; --INDEX'I DROP EDER SILER.

CREATE --FIRST_NAME VE LAST_NAME KOLONLARINA INDEX TANIMLAR.
INDEX PEOPLES_FIRST_NAME_LAST_NAME_IDX
ON PEOPLES(FIRST_NAME, LAST_NAME); --AD ve SOYADA GORE ARAMA YAPILIRKEN OKUMA HIZINI ARTIRMAK ICIN INDEX'LER OLUSTURULUR VE BINARY TREE ALGORITMASINA GORE ARAMA YAPAR.

SELECT *
FROM PEOPLES
WHERE FIRST_NAME = 'Jesus' AND LAST_NAME = 'Ramos'; -- OKUMA ARTIK COK DAHA HIZLI.

SELECT *
FROM PEOPLES
WHERE LAST_NAME = 'Ramos'; -- KOTU YONTEM YAVASLIYOR.

DROP
INDEX CUSTOMER_EMAIL_KEY; --HATA VERIR YANLIS YONTEM.

ALTER
TABLE CUSTOMER
DROP
CONSTRAINT CUSTOMER_EMAIL_KEY; --ILGILI KISITI/CONTRAINT'I DROP EDER SILER.

CREATE
UNIQUE INDEX CUSTOMER_EMAIL_IDX
ON CUSTOMER(EMAIL); --EMAIL ICIN HIZLI OKUMA. BENZERSIZ KISIT. AYNI EMAIL BIR DAHA GIRILEMEZ. BTREE(2'YE BOLEREK ARAMA ALGORITMASI)

--INDEX'LER TELEFON REHBERINE BENZERLER.

DROP
INDEX CUSTOMER_EMAIL_IDX;

CREATE
INDEX PRODUCT_DISCONTINUED_PARTIAL_IDX
ON PRODUCT(DISCONTINUED)
WHERE DISCONTINUED; --WHERE DISCONTINUED: Bu ifade, kısmi indeksin yalnızca DISCONTINUED sütunundaki true (veya 1) değerleri için oluşturulacağını belirtir. Bu, tüm satırlar yerine yalnızca belirli koşullara uyan satırlar için indeks oluşturur.
--Bu komut, yalnızca "discontinued" (satıştan kaldırılmış) ürünleri içeren satırlara indeks oluşturur. Bu sayede, veritabanı sorguları sadece bu koşula uyan satırlara odaklanarak daha hızlı çalışır, ancak diğer tüm satırlar için bir indeks oluşturulmaz. Bu da hem performans hem de depolama açısından avantaj sağlar.

--DISCONTINUED KOLONU FALSE OLANLAR INDEX'LER.
SELECT * FROM PRODUCT WHERE DISCONTINUED = FALSE; --PERFORMANS SAGLAR FALSE OLANLAR ICIN.
CREATE
INDEX PRODUCT_DISCONTINUED_PARTIAL_IDX
ON PRODUCT(DISCONTINUED)
WHERE NOT DISCONTINUED; --WHERE NOT DISCONTINUED: Bu kısım, sadece DISCONTINUED = false (ya da DISCONTINUED = 0) olan satırların indeksleneceğini belirtir. Yani, satışı devam eden (discontinued olmayan) ürünler bu indekse dahil edilecektir.

CREATE OR REPLACE FUNCTION FUNCTION_NAME(P INT, P2 TEXT)
RETURNS INT
LANGUAGE PLPGSQL
AS
$$
DECLARE --DEGISKEN TANIMLAMALARI
A INT; --TAM SAYI TURUNDE DEGISKEN
BEGIN --IS KODLARININ YAZILDIGI KISIM / KOD BLOGU {=BEGIN }=END
    RETURN;
END;
$$

SELECT COUNT(*)
FROM PEOPLES
WHERE FIRST_NAME = 'Jesus';

CREATE OR REPLACE FUNCTION COUNT_BY_FIRST_NAME(P_FIRST_NAME TEXT)
RETURNS INT
LANGUAGE PLPGSQL
AS
$$
DECLARE --DEGISKEN TANIMLAMALARI
    TOTAL INT; --TAM SAYI TURUNDE DEGISKEN
BEGIN --IS KODLARININ YAZILDIGI KISIM / KOD BLOGU {=BEGIN }=END
    SELECT COUNT(*)
    INTO TOTAL
    FROM PEOPLES
    WHERE FIRST_NAME = P_FIRST_NAME;

    RETURN TOTAL;
END;
$$

SELECT COUNT_BY_FIRST_NAME('Jesus');

DROP
FUNCTION COUNT_BY_FIRST_NAME;

